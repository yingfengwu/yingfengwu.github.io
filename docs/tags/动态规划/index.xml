<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>动态规划 - 标签 - yingfengwu</title>
        <link>https://yingfengwu.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
        <description>动态规划 - 标签 - yingfengwu</description>
        <generator>Hugo -- gohugo.io</generator><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 01 Jun 2021 17:57:40 &#43;0800</lastBuildDate><atom:link href="https://yingfengwu.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="self" type="application/rss+xml" /><item>
    <title>动态规划总结（多示例&#43;讲解）</title>
    <link>https://yingfengwu.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 01 Jun 2021 17:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://yingfengwu.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但 仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 比如，想去以下地方旅游4天，假设将埃菲尔铁塔加入“背包”后，卢浮宫将 更“便宜”：只要1天时间，而不是1.5天。用动态规划对这种情况建模呢？ 这是没办法建模的，因为存在依赖关系。
   景点 停留天数 评分     埃菲尔铁塔 1.5天 8   卢浮宫 1.5天 9   巴黎圣母院 1.5天 7    一、斐波那契数列求解 题目:
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
😂
递归法   原理： 把f(n)问题的计算拆分成 f(n-1)和f(n−2)两个子问题的计算，并递归，以f(0)和f(1)为终止条件。]]></description>
</item><item>
    <title>排序算法总结（多示例&#43;讲解）</title>
    <link>https://yingfengwu.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 01 Jun 2021 17:57:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://yingfengwu.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但 仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 比如，想去以下地方旅游4天，假设将埃菲尔铁塔加入“背包”后，卢浮宫将 更“便宜”：只要1天时间，而不是1.5天。用动态规划对这种情况建模呢？ 这是没办法建模的，因为存在依赖关系。
一、冒泡排序 1 2 3 4 5 6  def bubble_sort(arr): for i in range(0, len(arr)): # 对每个元素 for j in range(1, len(arr)-i): # 最大的往上冒，冒完需要减1避免再次计算该值 if arr[j] &gt; arr[j+1]: # 此处，&#34;&gt;&#34;为大的数往上冒，&#34;&lt;&#34;为小的数往上冒 arr[j], arr[j+1] = arr[j+1], arr[j] # 交换位置 return a   二、选择排序 1 2 3 4 5 6 7 8 9  def selection_sort(arr): for i in range(len(arr)-1): # 减1是为了第2个for的起始i+1 min_index = i for j in range(i+1, len(arr)): # 遍历后面的值，并记录最小值的索引 if arr[min_index] &gt; arr[j]: # 要是取最大值的索引，则改&#34;&gt;&#34;为&#34;&lt;&#34; min_index = j if i !]]></description>
</item></channel>
</rss>
